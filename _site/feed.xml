<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-09-02T21:15:59+07:00</updated><id>http://localhost:4000/</id><title type="html">Long Nhu Tran</title><subtitle>Front-end Web Development</subtitle><entry><title type="html">Performance and Resilience: Stress-Testing Third Parties</title><link href="http://localhost:4000/performance-and-resilience-stress-testing-third-parties/" rel="alternate" type="text/html" title="Performance and Resilience: Stress-Testing Third Parties" /><published>2017-07-31T23:10:13+07:00</published><updated>2017-07-31T23:10:13+07:00</updated><id>http://localhost:4000/performance-and-resilience-stress-testing-third-parties</id><content type="html" xml:base="http://localhost:4000/performance-and-resilience-stress-testing-third-parties/">&lt;p&gt;When building almost any website of any reasonable size, we’re highly likely to
need to call on at least some third party resources: analytics, fonts, CDNs, ad
providers, to name just a few.&lt;/p&gt;

&lt;p&gt;Unfortunately, this puts a lot of your ability to be fast in someone else’s
hands, and the vast majority of performance slowdowns I encounter in my work
are, indeed, caused by external resources that we have little-to-no control
over. These issues could range from network issues on a CDN leading to slower
delivery of assets, to external JavaScript using older APIs like
&lt;code class=&quot;highlighter-rouge&quot;&gt;document.write()&lt;/code&gt;; from third parties not properly compressing or caching their
resources, to ad networks not optimising their images; from third party
resources living on the Critical Path, to any combination of the above.&lt;/p&gt;

&lt;p&gt;The solutions to the above problems will range from trivial to non-existent and
will depend a lot on the third party in question, and on your own context. That
means that, in this post, I can’t necessarily discuss how to &lt;em&gt;fix&lt;/em&gt; these issues,
but I will show you a few tools you can use to identify and triage them and
learn just how susceptible you might be.&lt;/p&gt;

&lt;h2 id=&quot;bottom-up-summaries&quot;&gt;Bottom-Up Summaries&lt;/h2&gt;

&lt;p&gt;Rightly or wrongly, a lot of performance optimisation is about playing something
of a blame game: what, or &lt;em&gt;who&lt;/em&gt;, is making us slow? One of my favourite ways of
quickly working this out is to make use of DevTools’ &lt;em&gt;Bottom-Up&lt;/em&gt; summary of
runtime performance.&lt;/p&gt;

&lt;p&gt;After you’ve run a Performance profile over your page, you should see a pane
with a tab reading &lt;em&gt;Bottom-Up&lt;/em&gt;. Head over to this view, and select &lt;em&gt;Group
by Domain&lt;/em&gt; from the available dropdown. Amazing! Now we can see exactly where
our overhead is coming from:&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/wp-content/uploads/2017/07/screenshot-bottom-up.png&quot; alt=&quot;&quot; /&gt;
&lt;figcaption&gt;DevTool’s Bottom-Up feature. &lt;a href=&quot;/wp-content/uploads/2017/07/screenshot-bottom-up-full.png&quot;&gt;View full
size/quality (50KB).&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Above, we can see how &lt;code class=&quot;highlighter-rouge&quot;&gt;twitter.com&lt;/code&gt; contributes a third of the work that happens
when loading a page on my website. Using this knowledge, we can more accurately
pinpoint problem areas, and begin investigating with a bit of evidence behind
us. We can then take that knowledge, and use it with the following…&lt;/p&gt;

&lt;h2 id=&quot;request-blocking&quot;&gt;Request Blocking&lt;/h2&gt;

&lt;p&gt;As of &lt;a href=&quot;https://developers.google.com/web/updates/2017/04/devtools-release-notes#block-requests&quot;&gt;Chrome
59&lt;/a&gt;
(and long before that if you have Experiments enabled), we have the option to
prevent requests for specific asset URLs—or even assets on entire domains—from
going out. Whilst this doesn’t necessarily simulate any realistic network
conditions (the key thing to note with this feature is that it blocks outgoing
requests; it does not hit the network at all), it is a great way of seeing what
the absence of a particular asset would have on the current page.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/wp-content/uploads/2017/07/screenshot-request-blocking.png&quot; alt=&quot;&quot; /&gt;
&lt;figcaption&gt;The option to block requests from specific domains in DevTools. &lt;a href=&quot;/wp-content/uploads/2017/07/screenshot-request-blocking-full.png&quot;&gt;View
full size/quality (78KB).&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;In DevTools’ Network panel, after you’ve run a waterfall chart, you’re now able
to to right-click an individual asset and mark it for blocking: you can either
block outgoing requests for a single file, or for all files from an entire
domain.&lt;/p&gt;

&lt;h3 id=&quot;use-cases&quot;&gt;Use Cases&lt;/h3&gt;

&lt;p&gt;I usually use this feature when I’m running performance audits: when
I’m profiling a live website, I might get a hunch that a certain third party is
causing slowdowns. Previously, in order to verify this, you’d have to remove the
third party asset from the source code, roll a new release to a staging
environment, and re-run your tests with the asset removed so as to measure your
before and afters.&lt;/p&gt;

&lt;p&gt;Now, however, you can simply wonder &lt;q&gt;Hmm… I think this particular third party
tag manager is causing us some problems; let me quickly disable it and see what
happens.&lt;/q&gt; In fact, I did exactly this in front of a client only last week to
find that one particular third party JS file was contributing around half
a second of slowdown.&lt;/p&gt;

&lt;p&gt;In short, this feature is fantastic for profiling live sites and seeing exactly
what happens when we remove third party assets from the page load.&lt;/p&gt;

&lt;h2 id=&quot;charles-proxy&quot;&gt;Charles Proxy&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles&lt;/a&gt; is a great little Swiss Army knife of
a tool that I use quite frequently. It allows us to proxy HTTP traffic,
observing exchanges between our machine and the network. The bit we’re most
interested in right now, though, is its throttling feature. Charles’ throttling
capabilities are twofold:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Firstly, we can throttle our entire connection, simulating a poor network.
This is perfect for testing performance with empathy, using a forcibly worse
connection, and it a little more forensic than the similar feature found in
Chrome’s DevTools.&lt;/li&gt;
  &lt;li&gt;Secondly, and more pertinent to this article, is its ability only to throttle
specific hosts.&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt;
&lt;img src=&quot;/wp-content/uploads/2017/07/screenshot-charles-throttling.png&quot; alt=&quot;&quot; /&gt;
&lt;figcaption&gt;Charles Proxy’s throttling settings. &lt;a href=&quot;/wp-content/uploads/2017/07/screenshot-charles-throttling-full.png&quot;&gt;View
full size/quality (103KB).&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;Add a domain to the list, choose or configure a network condition, and begin
artificially slowing down traffic only from a specified host.&lt;/p&gt;

&lt;h3 id=&quot;use-cases-1&quot;&gt;Use Cases&lt;/h3&gt;

&lt;p&gt;It’s hopefully fairly self-explanatory, but this is a great way of assessing
what would happen if you weren’t necessarily on a slow connection, but if one of
your third parties was suffering a slowdown for whatever reason. What happens if
Google Fonts is having issues? What happens if Typekit gets DDoSed? Simulating
slowdowns on specific third parties is a good way to see how vulnerable we are.&lt;/p&gt;

&lt;h2 id=&quot;blackhole-servers&quot;&gt;Blackhole Servers&lt;/h2&gt;

&lt;p&gt;The most extreme of scenarios: what happens if a third party has a complete
outage? As rare as this may be, it’s prudent to at least know how your site will
respond in the case that a third party you use goes completely offline. Best
case scenario, you fail gracefully with minimal disruption; worst case scenario,
you go down with it.&lt;/p&gt;

&lt;p&gt;A blackhole server can be used to route third party traffic through an endpoint
that effectively makes requests disappear, recreating the effects of a complete
outage (only for yourself, not the entire internet).
&lt;a href=&quot;https://www.webpagetest.org/&quot;&gt;WebPagetest&lt;/a&gt; have made a blackhole server
available at &lt;code class=&quot;highlighter-rouge&quot;&gt;72.66.115.13&lt;/code&gt;. We can point specific domains at this IP address in
our &lt;code class=&quot;highlighter-rouge&quot;&gt;hosts&lt;/code&gt; file, e.g.:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;72.66.115.13 platform.twitter.com
72.66.115.13 connect.facebook.net
72.66.115.13 fonts.googleapis.com
72.66.115.13 assets.adobedtm.com
72.66.115.13 fast.fonts.net
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now—if you’ve cleared your browser’s and machine’s DNS cache—you should find
that all requests to assets on those domains will eventually time out. This is
where we begin to see interesting, and often much more severe, results.&lt;/p&gt;

&lt;p&gt;Let’s say you have a render-blocking asset hosted on an external domain, for
example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt; that doesn’t have an &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; attribute, such as Adobe
Tag Manager, or;&lt;/li&gt;
  &lt;li&gt;A CSS file, such as Google Fonts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Because these types of assets block rendering, the browser will not paint
anything to the screen until they have been downloaded (and executed/parsed). If
the service that provides the file is offline, then that’s a lot of time that
the browser has to spend &lt;em&gt;trying&lt;/em&gt; to access the file, and during that period the
user is left potentially looking at a blank screen. After a certain period has
elapsed, the browser will eventually timeout and display the page without the
asset(s) in question. How long is that certain period of time?&lt;/p&gt;

&lt;p&gt;It’s &lt;strong&gt;1 minute and 20 seconds.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you have any render-blocking, critical, third party assets hosted on an
external domain, you run the risk of showing users a blank page for 1.3 minutes.&lt;/p&gt;

&lt;p&gt;Below, you’ll see the &lt;code class=&quot;highlighter-rouge&quot;&gt;DOMContentLoaded&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Load&lt;/code&gt; events on a site that has
a render-blocking script hosted elsewhere. The browser was completely held up
for 78 seconds, showing nothing at all until it ended up timing out.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/wp-content/uploads/2017/07/screenshot-outage.png&quot; alt=&quot;&quot; /&gt;
&lt;figcaption&gt;A 1.3 minute &lt;code&gt;DOMContentLoaded&lt;/code&gt; and &lt;code&gt;Load&lt;/code&gt;
event when Adobe Tag Manager is offline. &lt;a href=&quot;/wp-content/uploads/2017/07/screenshot-outage-full.png&quot;&gt;View full
size/quality (375KB).&lt;/a&gt;&lt;/figcaption&gt;
&lt;/figure&gt;

&lt;p&gt;It’s very important to point out that &lt;strong&gt;this isn’t necessarily the third party’s
fault&lt;/strong&gt;. The behaviour outlined above is expected: it’s how web pages and
browsers work. What we’re doing here is not apportioning blame, but learning
about how resilient &lt;em&gt;we&lt;/em&gt; are if one of our third parties goes down.&lt;/p&gt;

&lt;p&gt;Oftentimes, we don’t consider the implications or ramifications of such
scenarios, and we rarely realise just how severe the outcomes can be. I would
wholeheartedly recommend identifying and then testing any critical third parties
you have hosted on external domains.&lt;/p&gt;

&lt;p&gt;In the case of something like a Google Fonts CSS file, we should be using a more
robust and failsafe font-loading technique; in the case of JavaScript, we should
try utilising &lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;defer&lt;/code&gt; if possible.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Like it or not, third party providers are a necessary evil in almost all
development projects, and if we’re going to entrust parts of our site or product
to others, we ought to have a very good idea of what happens when things go
wrong. Stress-testing third parties is a standard part of any of the bits of
performance work I undertake, because the ramifications can be huge. And again,
this isn’t us blaming the providers: it’s finding out how well we handle
failures.&lt;/p&gt;</content><author><name></name></author><summary type="html">When building almost any website of any reasonable size, we’re highly likely to need to call on at least some third party resources: analytics, fonts, CDNs, ad providers, to name just a few.</summary></entry><entry><title type="html">Refactoring Tunnels</title><link href="http://localhost:4000/refactoring-tunnels/" rel="alternate" type="text/html" title="Refactoring Tunnels" /><published>2017-06-02T19:19:58+07:00</published><updated>2017-06-02T19:19:58+07:00</updated><id>http://localhost:4000/refactoring-tunnels</id><content type="html" xml:base="http://localhost:4000/refactoring-tunnels/">&lt;p&gt;In my work, I tend to get involved in a lot of refactoring projects. From
small-scale tweaks of work-in-progress frameworks or styleguides, right through
to full-scale refactors of years-old legacy projects. In fact, I do so much work
with clients who need to refactor that I spent &lt;a href=&quot;https://speakerdeck.com/csswizardry/refactoring-css-without-losing-your-mind&quot;&gt;much of 2016 speaking about
it&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;There are many interesting things about refactoring—from technical to
logistical to cultural—but two points that are most relevant to this article
are:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;The business is almost always hesitant to fund refactoring work&lt;/strong&gt;. Nearly
every development team I have ever spoken to has told me that their manager
or client is the main reason they do not get to refactor as often as they
would like to. This is understandable: the cost of moving developers away
from product work to rewrite code with no discernible benefit to the user&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;
is a cost that most managers would rather not incur.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Refactoring can be scary.&lt;/strong&gt; On a sufficiently large or legacy application,
there can be so much fundamentally wrong with the codebase that many
refactoring tasks will run very deep throughout the whole project. This puts
a lot of pressure on developers, especially considering that this is their
chance to &lt;q&gt;get it right this time&lt;/q&gt;. This can feel debilitating: &lt;q&gt;Where
do I start?&lt;/q&gt; &lt;q&gt;How long is this going to take?&lt;/q&gt; &lt;q&gt;How will I know if
I’m doing the right thing?&lt;/q&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A concept I came up with to help my clients and their teams tackle these two
problems was the idea of a &lt;em&gt;Refactoring Tunnel&lt;/em&gt;.&lt;/p&gt;

&lt;figure&gt;
&lt;img src=&quot;/wp-content/uploads/2017/06/tunnel.jpg&quot; alt=&quot;&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;A Refactoring Tunnel is a metaphor in which the length or size of the
refactoring task is represented by a tunnel of a corresponding size: long
tunnels represent large refactoring tasks; short tunnels represent small ones.&lt;/p&gt;

&lt;p&gt;A more developer oriented way of looking at or defining the size of
a refactoring task might be to describe its surface area: how much of the
codebase does the body of work touch?&lt;/p&gt;

&lt;p&gt;The Refactoring Tunnel metaphor works like this:&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;On day one, you pick your refactoring task: you step into the tunnel. At this
point, you can see the light at the tunnel’s entrance behind you, but you can’t
see the light at the exit—perhaps it’s close but around a sharp bend, or maybe
it is just that far away. At this point, we don’t know, but it doesn’t concern
us because we have only just started.&lt;/p&gt;

&lt;p&gt;Day two: we continue working on our refactoring task, and proceed further into
the tunnel. Just like yesterday, we can still see the light at the entrance
behind us, but the light at the exit still evades us. That is to say, we have
a good idea of where we’ve come from, but still don’t know how far away the exit
is: is it another week? Two weeks? Three days?&lt;/p&gt;

&lt;p&gt;We press on, day after day making our way further into the tunnel, until day
nine. All of a sudden, the light behind us has disappeared. We know we did nine
days of work, but we’ve now lost the security of being able to see a fixed point
behind us.&lt;/p&gt;

&lt;p&gt;To compound the problem, we still can’t see the light at the exit either. The
panic sets in; we’re lost. The site is broken around our feet. The &lt;q&gt;quick
find-and-replace&lt;/q&gt; for the class names didn’t work as we’d hoped, and now some
JavaScript has stopped working. Many of our tests are failing, but we’re not
sure why. We’ve tried to keep merging &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; into our topic branch, but we see
more and more merge conflicts. And we still have no idea where the exit is. Is
it quite close? Would it be worth continuing another day or so? Or is it still
many days—or even weeks—away from us? We have no way of knowing. The uncertainty
is stressful; it is a gamble. We begin to wish we’d never started, and in total
desperation, we do this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git reset --hard origin/master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We just throw everything away. We hard reset ourselves to a point in time we
knew to be safe—and we do begin to feel safer again—but we have to face up to
the fact that we just spent nine days of time and money getting to precisely
nowhere. That’s going to be a difficult one to explain at your stand up, and
will likely reduce the chances of the business trusting developers with
refactoring time in future.&lt;/p&gt;

&lt;p&gt;I’ve done this, and seen it done, more times than I would care to remember (or
admit). I’m sure you’ve done it at some point as well. This is the danger of
entering long Refactoring Tunnels.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Tasks with a large surface area—and thus, a long tunnel—might be things like&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;rewriting all of your Sass as PostCSS;&lt;/li&gt;
  &lt;li&gt;renaming all of your classes from BEM to BEM(IT), or;&lt;/li&gt;
  &lt;li&gt;moving your entire project’s layout from floats to Grid.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While each of these may be worthy and worthwhile changes to make, they’re
relatively large. They will affect and modify the entire project’s codebase,
which means a few things:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;It will take a lot of time to implement and test.&lt;/strong&gt; Even if you get it
right first time, it’s a significant spend that you will have to be able to
justify.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The likelihood of introducing new bugs and regressions increases.&lt;/strong&gt; It
stands to reason that if you’re impacting large and far-reaching parts of
your codebase, you are far more likely to introduce new or
different faults along the way inadvertently.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The chance of pesky merge conflicts goes up.&lt;/strong&gt; As oddly-specific as it
might seem, this is a real issue. Diverging from your colleagues’ codebases
on such a massive scale means you’re going to run into workflow issues.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;It may well become overwhelming. Scary, even.&lt;/strong&gt; The most drastic outcome is
that you realise you’ve bitten off more than you can chew and you have to
bail out completely.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Don’t enter a tunnel whose end you can’t see, or that you can’t exit from
quickly and cheaply.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;short-refactoring-tunnels&quot;&gt;Short Refactoring Tunnels&lt;/h2&gt;

&lt;p&gt;Resist the temptation to refactor anything that runs right the way throughout
the project. Instead, identify smaller and more manageable tasks: tasks that
have a much smaller surface area, and therefore a much shorter Refactoring
Tunnel.&lt;/p&gt;

&lt;p&gt;These tasks can still aim toward a larger and more total goal but can be
realised in much safer and shorter timeframes. Want to move all of your
classes from BEM to BEM(IT)? Sure, but maybe just implement it on the nav first.
Attacking the problem this way has many benefits:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;You’re minimising your liabilities.&lt;/strong&gt; The maximum risk at any given time is
significantly reduced. Even in the worst case scenario, we only need to abort
a much smaller piece of work.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;The shorter tunnel can be used as a test-bed for larger bodies of work.&lt;/strong&gt;
This will help you work out projected overall cost based on a smaller sample.
It will allow you to stress-test certain new techniques, methodologies, or
approaches in a smaller sandbox. The upshot of this is that the overall
refactoring project can be defined based on a more trivial task up front.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;You can move back onto product work much sooner.&lt;/strong&gt; This keeps managers
happy—the fact that you’re only out of action for a few days, rather than
many weeks, at a time is a hugely attractive proposition and is more likely
to get approval than the alternative.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;It’s a chance to encapsulate.&lt;/strong&gt; By working in these smaller units, it
becomes almost necessary to begin defensively encapsulating code as you
refactor it. This means that your codebase will gradually become more robust
as a result, which will help with almost all future work.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Your overall goals for the project can remain the same but try to &lt;a href=&quot;https://csswizardry.com/2016/08/refactoring-css-the-three-i-s/&quot;&gt;identify and
isolate&lt;/a&gt; the
sub-tasks into much smaller and safer units. Make sure you only ever step into
short tunnels.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;I firmly believe that the user will ultimately benefit from a refactored codebase, but in ways that are hard to actually measure.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">In my work, I tend to get involved in a lot of refactoring projects. From small-scale tweaks of work-in-progress frameworks or styleguides, right through to full-scale refactors of years-old legacy projects. In fact, I do so much work with clients who need to refactor that I spent much of 2016 speaking about it.</summary></entry><entry><title type="html">You’re up and running!</title><link href="http://localhost:4000/Hello-World/" rel="alternate" type="text/html" title="You're up and running!" /><published>2014-03-03T00:00:00+07:00</published><updated>2014-03-03T00:00:00+07:00</updated><id>http://localhost:4000/Hello-World</id><content type="html" xml:base="http://localhost:4000/Hello-World/">&lt;p&gt;Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/config.png&quot; alt=&quot;_config.yml&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The easiest way to make your first post is to edit this one. Go into /_posts/ and update the Hello World markdown file. For more instructions head over to the &lt;a href=&quot;https://github.com/barryclark/jekyll-now&quot;&gt;Jekyll Now repository&lt;/a&gt; on GitHub.&lt;/p&gt;</content><author><name></name></author><summary type="html">Next you can update your site name, avatar and other options using the _config.yml file in the root of your repository (shown below).</summary></entry></feed>